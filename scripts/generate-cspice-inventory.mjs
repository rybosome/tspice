#!/usr/bin/env node

import { readFile, readdir, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";

const CSPICE_INDEX_URL =
  "https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/index.html";

const REPO_ROOT = path.resolve(process.cwd());
const BACKEND_CONTRACT_DOMAINS_DIR = path.join(
  REPO_ROOT,
  "packages/backend-contract/src/domains",
);
const OUTPUT_PATH = path.join(REPO_ROOT, "docs/cspice-function-inventory.md");

function normalizeRoutineName(name) {
  const lower = name.toLowerCase();
  return lower.endsWith("_c") ? lower.slice(0, -2) : lower;
}

function shouldOmitTargetSupport({ name, purpose }) {
  // Keep omissions minimal.

  // (1) Interactive terminal I/O / command-line parsing.
  if (new Set(["prompt_c", "getcml_c"]).has(name)) {
    return {
      omit: true,
      justification: "interactive I/O / CLI",
    };
  }

  // (2) Fortran unit file I/O shims are not meaningful in tspice.
  if (/^ftn[a-z0-9]*_c$/.test(name) || purpose.toLowerCase().includes("fortran unit")) {
    return {
      omit: true,
      justification: "Fortran unit I/O (non-portable)",
    };
  }

  return { omit: false, justification: "" };
}

function parseCspiceIndexHtml(html) {
  const flattened = html.replace(/\s+/g, " ");

  const anchorCount = (flattened.match(/<LI><SAMP><A HREF/gi) ?? []).length;

  /** @type {{name: string; purpose: string}[]} */
  const routines = [];

  // Example:
  // <LI><SAMP><A HREF="furnsh_c.html">FURNSH_C</A> -  Furnish a program with SPICE kernels  </SAMP></LI>
  const entryRe =
    /<LI><SAMP><A HREF="[^"]+">([^<]+)<\/A>\s*-\s*(.*?)\s*<\/SAMP><\/LI>/gi;

  let match;
  while ((match = entryRe.exec(flattened))) {
    const rawName = match[1].trim();
    const rawPurpose = match[2].trim();

    // NAIF uses upper-case in the index.
    const name = rawName.toLowerCase();
    const purpose = rawPurpose.replace(/\s+/g, " ").trim();

    // Skip any oddities that aren't routine names.
    if (!name) continue;

    routines.push({ name, purpose });
  }

  // Deduplicate just in case.
  const byName = new Map();
  for (const r of routines) {
    byName.set(r.name, r);
  }

  const parsed = [...byName.values()].sort((a, b) => a.name.localeCompare(b.name));

  if (anchorCount !== 0 && parsed.length !== anchorCount) {
    throw new Error(
      `Parsed CSPICE routine count mismatch: parsed=${parsed.length} htmlAnchors=${anchorCount}`,
    );
  }

  return parsed;
}

async function fetchCspiceIndex() {
  const res = await fetch(CSPICE_INDEX_URL);
  if (!res.ok) {
    throw new Error(`Failed to fetch CSPICE index: ${res.status} ${res.statusText}`);
  }
  return await res.text();
}

function collectBackendContractApiMethods(sourceText) {
  // We avoid a TypeScript AST dependency here.
  // All current backend-contract domain files define interfaces with method
  // signatures like:
  //
  //   export interface FooApi {
  //     someMethod(arg: string): number;
  //     otherMethod(
  //       a: number,
  //       b: number,
  //     ): void;
  //   }
  //
  // We can reliably extract method names by matching identifiers at the start
  // of a line followed by an opening parenthesis.

  /** @type {string[]} */
  const names = [];
  const methodRe = /^\s*([A-Za-z_][A-Za-z0-9_]*)\s*(?:<[^>]*>)?\s*\(/gm;

  let match;
  while ((match = methodRe.exec(sourceText))) {
    const name = match[1];

    // Exclude false positives.
    if (name === "export" || name === "interface") continue;
    names.push(name);
  }

  return names;
}

async function collectImplementedRoutineNames() {
  const entries = await readdir(BACKEND_CONTRACT_DOMAINS_DIR, { withFileTypes: true });
  const tsFiles = entries
    .filter((e) => e.isFile() && e.name.endsWith(".ts"))
    .map((e) => path.join(BACKEND_CONTRACT_DOMAINS_DIR, e.name))
    .sort();

  /** @type {Set<string>} */
  const methodNames = new Set();

  for (const filePath of tsFiles) {
    const sourceText = await readFile(filePath, "utf8");
    const methods = collectBackendContractApiMethods(sourceText);
    for (const m of methods) {
      methodNames.add(m);
    }
  }

  /** @type {Set<string>} */
  const normalized = new Set();
  for (const m of methodNames) {
    normalized.add(normalizeRoutineName(m));
  }

  return { methodNames, normalized };
}

function checkbox(checked) {
  return checked ? "[x]" : "[ ]";
}

function escapeTableCell(text) {
  return text.replace(/\|/g, "\\|");
}

function renderMarkdown({ routines, implementedNormalized }) {
  const lines = [];

  lines.push("# CSPICE routine inventory");
  lines.push("");
  lines.push(
    "This file is generated by `node scripts/generate-cspice-inventory.mjs`.",
  );
  lines.push("");
  lines.push("Sources:");
  lines.push(
    `- CSPICE routine list + brief descriptions: ${CSPICE_INDEX_URL} (NAIF official index)`,
  );
  lines.push(
    "- tspice implemented routines: backend contract method names in `packages/backend-contract/src/domains/*.ts`",
  );
  lines.push("");
  lines.push("Legend: `[x]` = yes, `[ ]` = no.");
  lines.push("");

  lines.push(
    "| Function | Purpose (1 line) | Implemented now? | Target support? | Justification |",
  );
  lines.push("| --- | --- | --- | --- | --- |");

  const omitted = [];

  for (const r of routines) {
    const normalized = normalizeRoutineName(r.name);
    const implementedNow = implementedNormalized.has(normalized);

    const { omit, justification: omitJustification } = shouldOmitTargetSupport(r);

    // If it's already implemented, it's by definition supported.
    const targetSupport = implementedNow ? true : !omit;

    let justification;
    if (implementedNow) justification = "essential function";
    else if (targetSupport) justification = "parity with CSPICE";
    else justification = omitJustification;

    if (!targetSupport) {
      omitted.push({ ...r, justification });
    }

    lines.push(
      `| \`${r.name}\` | ${escapeTableCell(r.purpose)} | ${checkbox(implementedNow)} | ${checkbox(targetSupport)} | ${escapeTableCell(justification)} |`,
    );
  }

  lines.push("");
  lines.push("## Omitted routines (not targeted)");
  lines.push("");

  if (omitted.length === 0) {
    lines.push("None. All CSPICE routines are currently targeted for support.");
    return lines.join("\n");
  }

  lines.push(
    `A small number of CSPICE routines are marked as not targeted (${omitted.length} total). These are routines that don't translate well to tspice's scope:`,
  );
  lines.push("");

  const grouped = new Map();
  for (const r of omitted) {
    const arr = grouped.get(r.justification) ?? [];
    arr.push(r);
    grouped.set(r.justification, arr);
  }

  for (const [why, items] of [...grouped.entries()].sort((a, b) =>
    a[0].localeCompare(b[0]),
  )) {
    const examples = items
      .map((r) => `\`${r.name}\``)
      .sort((a, b) => a.localeCompare(b))
      .slice(0, 8)
      .join(", ");
    const suffix = items.length > 8 ? ", ..." : "";
    lines.push(`- **${why}**: ${items.length} routines (e.g. ${examples}${suffix})`);
  }

  return lines.join("\n");
}

async function main() {
  const html = await fetchCspiceIndex();
  const routines = parseCspiceIndexHtml(html);

  const { normalized: implementedNormalized } = await collectImplementedRoutineNames();

  const markdown = renderMarkdown({ routines, implementedNormalized });

  await writeFile(OUTPUT_PATH, markdown + "\n", "utf8");

  const total = routines.length;
  const implementedCount = routines.filter((r) =>
    implementedNormalized.has(normalizeRoutineName(r.name)),
  ).length;

  process.stdout.write(
    `Wrote ${path.relative(REPO_ROOT, OUTPUT_PATH)} (CSPICE routines: ${total}, implemented by tspice: ${implementedCount}).\n`,
  );
}

await main();
