#!/usr/bin/env node

import { mkdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const SCRIPT_DIR = path.dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = path.resolve(SCRIPT_DIR, "..");
const CSPICE_FUNCTIONS_JSON_PATH = path.join(REPO_ROOT, "data/cspice-functions.json");
const DOMAIN_RULES_JSON_PATH = path.join(REPO_ROOT, "data/cspice-function-domain-rules.json");
const DEFAULT_OUTPUT_PATH = path.join(
  REPO_ROOT,
  "docs/cspice-planned-functions-by-domain.md",
);

function normalizeRoutineName(name) {
  const lower = name.toLowerCase();
  return lower.endsWith("_c") ? lower.slice(0, -2) : lower;
}

function usage() {
  return [
    "Usage: node scripts/generate-cspice-planned-functions-by-domain.mjs [--out <path>] [--stdout] [--check]",
    "",
    "Default: regenerate docs/cspice-planned-functions-by-domain.md from data/cspice-functions.json.",
    "",
    "Options:",
    "  --out <path>  Write output to this path (default: docs/cspice-planned-functions-by-domain.md).",
    "  --stdout      Write markdown to stdout (status/logs to stderr).",
    "  --check       Fail if output file is out of date.",
  ].join("\n");
}

function parseArgs(argv) {
  /** @type {{ check: boolean; stdout: boolean; outPath: string }} */
  const out = {
    check: false,
    stdout: false,
    outPath: DEFAULT_OUTPUT_PATH,
  };

  if (argv.includes("--help") || argv.includes("-h")) {
    process.stdout.write(usage() + "\n");
    process.exit(0);
  }

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];

    if (a === "--check") {
      out.check = true;
      continue;
    }

    if (a === "--stdout") {
      out.stdout = true;
      continue;
    }

    if (a === "--out") {
      const v = argv[i + 1];
      if (!v || v.startsWith("-")) {
        throw new Error(`--out requires a path\n\n${usage()}`);
      }
      out.outPath = path.isAbsolute(v) ? path.resolve(v) : path.resolve(REPO_ROOT, v);
      i++;
      continue;
    }

    if (a.startsWith("-")) {
      throw new Error(`Unknown arg: ${a}\n\n${usage()}`);
    }

    throw new Error(`Unexpected positional arg: ${a}\n\n${usage()}`);
  }

  if (out.check && out.stdout) {
    throw new Error(`--check and --stdout are mutually exclusive\n\n${usage()}`);
  }

  return out;
}

function normalizePurpose(purpose) {
  return String(purpose ?? "")
    .replace(/\s+/g, " ")
    .trim();
}

function compileRules(ruleConfig) {
  /** @type {{ domain: string; test: (routine: {name: string; baseName: string; purpose: string}) => boolean }[]} */
  const compiled = [];

  for (const rule of ruleConfig.rules ?? []) {
    if (!rule.domain || !rule.type || !rule.pattern) {
      throw new Error(`Invalid rule: ${JSON.stringify(rule)}`);
    }

    if (rule.type === "regex") {
      const re = new RegExp(rule.pattern, "i");
      compiled.push({
        domain: rule.domain,
        test: ({ baseName }) => re.test(baseName),
      });
      continue;
    }

    if (rule.type === "purposeIncludes") {
      const needle = String(rule.pattern).toLowerCase();
      compiled.push({
        domain: rule.domain,
        test: ({ purpose }) => purpose.toLowerCase().includes(needle),
      });
      continue;
    }

    throw new Error(`Unknown rule type: ${rule.type}`);
  }

  return compiled;
}

function renderMarkdown({ plannedRoutines, domains, grouped, fallbackDomain, unmatchedCount }) {
  /** @type {string[]} */
  const lines = [];

  lines.push("# CSPICE planned routines by proposed domain");
  lines.push("");
  lines.push(
    `> Generated by \`node scripts/generate-cspice-planned-functions-by-domain.mjs\` from \`data/cspice-functions.json\` + \`data/cspice-function-domain-rules.json\`.`,
  );
  lines.push("");
  lines.push(
    `This is a **proposal** for how to group the CSPICE routines that are currently marked as \`planned\` in this repo.`,
  );
  lines.push("");

  lines.push("## Summary");
  lines.push("");
  lines.push(`Planned routines: **${plannedRoutines.length}**`);
  if (unmatchedCount > 0) {
    lines.push(`Fallback (\`${fallbackDomain}\`) routines: **${unmatchedCount}**`);
  }
  lines.push("");

  lines.push("## Proposed taxonomy");
  lines.push("");
  lines.push("| Domain | Count | Description |");
  lines.push("| --- | ---: | --- |");
  for (const d of domains) {
    const count = grouped.get(d.id)?.length ?? 0;
    lines.push(`| \`${d.id}\` | ${count} | ${d.description} |`);
  }
  lines.push("");

  for (const d of domains) {
    const routines = (grouped.get(d.id) ?? []).slice().sort((a, b) => a.name.localeCompare(b.name));

    lines.push(`## ${d.title} (\`${d.id}\`)`);
    lines.push("");

    if (routines.length === 0) {
      lines.push("_No planned routines currently classified here._");
      lines.push("");
      continue;
    }

    for (const r of routines) {
      const purpose = normalizePurpose(r.purpose);
      lines.push(`- \`${r.name}\` â€” ${purpose || "(no purpose in source data)"}`);
    }

    lines.push("");

    if (d.id === fallbackDomain) {
      lines.push("### Uncertain / needs review");
      lines.push("");
      lines.push(
        "These routines hit the classification fallback. They are fully accounted for above, but the domain assignment should be reviewed.",
      );
      lines.push("");
    }
  }

  return lines.join("\n");
}

async function main() {
  const { check, stdout, outPath } = parseArgs(process.argv.slice(2));

  const [rawFunctionsJson, rawRulesJson] = await Promise.all([
    readFile(CSPICE_FUNCTIONS_JSON_PATH, "utf8"),
    readFile(DOMAIN_RULES_JSON_PATH, "utf8"),
  ]);

  /** @type {{name: string; purpose: string; decision: string}[]} */
  const allRoutines = JSON.parse(rawFunctionsJson);

  /** @type {{fallbackDomain: string; domains: {id: string; title: string; description: string}[]; overrides?: Record<string, string>; rules: any[]}} */
  const ruleConfig = JSON.parse(rawRulesJson);

  const planned = allRoutines
    .filter((r) => r.decision === "planned")
    .map((r) => ({
      name: r.name.toLowerCase(),
      baseName: normalizeRoutineName(r.name),
      purpose: normalizePurpose(r.purpose),
    }));

  const plannedBaseNames = new Set(planned.map((r) => r.baseName));

  const domainIds = new Set(ruleConfig.domains.map((d) => d.id));
  if (!domainIds.has(ruleConfig.fallbackDomain)) {
    throw new Error(
      `fallbackDomain=\"${ruleConfig.fallbackDomain}\" is not present in domains list`,
    );
  }

  /** @type {Map<string, string>} */
  const overrides = new Map();
  for (const [rawKey, rawDomain] of Object.entries(ruleConfig.overrides ?? {})) {
    const key = normalizeRoutineName(rawKey);
    if (overrides.has(key)) {
      throw new Error(
        `Duplicate override key after normalization: ${JSON.stringify(rawKey)} -> ${JSON.stringify(key)}`,
      );
    }
    if (!plannedBaseNames.has(key)) {
      throw new Error(
        `Override key ${JSON.stringify(rawKey)} (normalized: ${JSON.stringify(key)}) does not match any planned routine`,
      );
    }
    if (!domainIds.has(rawDomain)) {
      throw new Error(`Override for ${rawKey} references unknown domain: ${rawDomain}`);
    }
    overrides.set(key, rawDomain);
  }

  const compiledRules = compileRules(ruleConfig);

  /** @type {Map<string, {name: string; baseName: string; purpose: string}[]>} */
  const grouped = new Map();
  for (const d of ruleConfig.domains) grouped.set(d.id, []);

  let fallbackCount = 0;

  for (const r of planned) {
    const override = overrides.get(r.baseName);
    let domain = override;

    if (!domain) {
      for (const rule of compiledRules) {
        if (rule.test(r)) {
          domain = rule.domain;
          break;
        }
      }
    }

    if (!domain) {
      domain = ruleConfig.fallbackDomain;
      fallbackCount++;
    }

    if (!domainIds.has(domain)) {
      throw new Error(`Routine ${r.name} assigned unknown domain: ${domain}`);
    }

    grouped.get(domain).push(r);
  }

  const md = renderMarkdown({
    plannedRoutines: planned,
    domains: ruleConfig.domains,
    grouped,
    fallbackDomain: ruleConfig.fallbackDomain,
    unmatchedCount: fallbackCount,
  });

  await mkdir(path.dirname(outPath), { recursive: true });

  if (check) {
    const existing = await readFile(outPath, "utf8").catch((err) => {
      if (err?.code === "ENOENT") return null;
      throw err;
    });
    if (existing !== md) {
      const relOutPath = path.relative(REPO_ROOT, outPath);
      const outFlag =
        path.resolve(outPath) === path.resolve(DEFAULT_OUTPUT_PATH)
          ? ""
          : ` --out ${relOutPath}`;

      process.stderr.write(
        `${relOutPath} is ${existing === null ? "missing" : "out of date"}. Re-run:\n\n  node scripts/generate-cspice-planned-functions-by-domain.mjs${outFlag}\n`,
      );
      process.exit(1);
    }
    return;
  }

  if (stdout) {
    process.stdout.write(md);
    if (!md.endsWith("\n")) process.stdout.write("\n");
    process.stderr.write(`Fallback (\\\"${ruleConfig.fallbackDomain}\\\") classified: ${fallbackCount}\n`);
    return;
  }

  await writeFile(outPath, md, "utf8");
  process.stdout.write(`Wrote ${path.relative(REPO_ROOT, outPath)}\n`);
  process.stdout.write(`Fallback (\\\"${ruleConfig.fallbackDomain}\\\") classified: ${fallbackCount}\n`);
}

main().catch((err) => {
  process.stderr.write(String(err?.stack ?? err) + "\n");
  process.exit(1);
});
