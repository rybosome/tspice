#!/usr/bin/env node

import { mkdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";

const REPO_ROOT = path.resolve(process.cwd());
const CSPICE_FUNCTIONS_JSON_PATH = path.join(REPO_ROOT, "data/cspice-functions.json");
const DOMAIN_RULES_JSON_PATH = path.join(REPO_ROOT, "data/cspice-function-domain-rules.json");
const OUTPUT_PATH = path.join(REPO_ROOT, "docs/cspice-planned-functions-by-domain.md");

function normalizeRoutineName(name) {
  const lower = name.toLowerCase();
  return lower.endsWith("_c") ? lower.slice(0, -2) : lower;
}

function usage() {
  return [
    "Usage: node scripts/generate-cspice-planned-functions-by-domain.mjs [--check]",
    "",
    "Default: regenerate docs/cspice-planned-functions-by-domain.md from data/cspice-functions.json.",
    "",
    "Modes:",
    "  --check  Fail if docs/cspice-planned-functions-by-domain.md is out of date.",
  ].join("\n");
}

function parseArgs(argv) {
  const args = new Set(argv);

  if (args.has("--help") || args.has("-h")) {
    process.stdout.write(usage() + "\n");
    process.exit(0);
  }

  const check = args.has("--check");

  const allowed = new Set(["--check"]);
  for (const a of args) {
    if (a.startsWith("-") && !allowed.has(a)) {
      throw new Error(`Unknown arg: ${a}\n\n${usage()}`);
    }
  }

  return { check };
}

function normalizePurpose(purpose) {
  return String(purpose ?? "")
    .replace(/\s+/g, " ")
    .trim();
}

function compileRules(ruleConfig) {
  /** @type {{ domain: string; test: (routine: {name: string; baseName: string; purpose: string}) => boolean }[]} */
  const compiled = [];

  for (const rule of ruleConfig.rules ?? []) {
    if (!rule.domain || !rule.type || !rule.pattern) {
      throw new Error(`Invalid rule: ${JSON.stringify(rule)}`);
    }

    if (rule.type === "regex") {
      const re = new RegExp(rule.pattern, "i");
      compiled.push({
        domain: rule.domain,
        test: ({ baseName }) => re.test(baseName),
      });
      continue;
    }

    if (rule.type === "purposeIncludes") {
      const needle = String(rule.pattern).toLowerCase();
      compiled.push({
        domain: rule.domain,
        test: ({ purpose }) => purpose.toLowerCase().includes(needle),
      });
      continue;
    }

    throw new Error(`Unknown rule type: ${rule.type}`);
  }

  return compiled;
}

function renderMarkdown({ plannedRoutines, domains, grouped, fallbackDomain, unmatchedCount }) {
  /** @type {string[]} */
  const lines = [];

  lines.push("# CSPICE planned routines by proposed domain");
  lines.push("");
  lines.push(
    `> Generated by \`node scripts/generate-cspice-planned-functions-by-domain.mjs\` from \`data/cspice-functions.json\` + \`data/cspice-function-domain-rules.json\`.`,
  );  lines.push("");
  lines.push(
    `This is a **proposal** for how to group the CSPICE routines that are currently marked as \`planned\` in this repo.`,
  );
  lines.push("");

  lines.push("## Summary");
  lines.push("");
  lines.push(`Planned routines: **${plannedRoutines.length}**`);
  if (unmatchedCount > 0) {
    lines.push(`Fallback (\`${fallbackDomain}\`) routines: **${unmatchedCount}**`);
  }
  lines.push("");

  lines.push("## Proposed taxonomy");
  lines.push("");
  lines.push("| Domain | Count | Description |");
  lines.push("| --- | ---: | --- |");
  for (const d of domains) {
    const count = grouped.get(d.id)?.length ?? 0;
    lines.push(`| \`${d.id}\` | ${count} | ${d.description} |`);
  }
  lines.push("");

  for (const d of domains) {
    const routines = (grouped.get(d.id) ?? []).slice().sort((a, b) => a.name.localeCompare(b.name));

    lines.push(`## ${d.title} (\`${d.id}\`)`);
    lines.push("");

    if (routines.length === 0) {
      lines.push("_No planned routines currently classified here._");
      lines.push("");
      continue;
    }

    for (const r of routines) {
      const purpose = normalizePurpose(r.purpose);
      lines.push(`- \`${r.name}\` â€” ${purpose || "(no purpose in source data)"}`);
    }

    lines.push("");

    if (d.id === fallbackDomain) {
      lines.push("### Uncertain / needs review");
      lines.push("");
      lines.push(
        "These routines hit the classification fallback. They are fully accounted for above, but the domain assignment should be reviewed.",
      );
      lines.push("");
    }
  }

  return lines.join("\n");
}

async function main() {
  const { check } = parseArgs(process.argv.slice(2));

  const [rawFunctionsJson, rawRulesJson] = await Promise.all([
    readFile(CSPICE_FUNCTIONS_JSON_PATH, "utf8"),
    readFile(DOMAIN_RULES_JSON_PATH, "utf8"),
  ]);

  /** @type {{name: string; purpose: string; decision: string}[]} */
  const allRoutines = JSON.parse(rawFunctionsJson);

  /** @type {{fallbackDomain: string; domains: {id: string; title: string; description: string}[]; overrides?: Record<string, string>; rules: any[]}} */
  const ruleConfig = JSON.parse(rawRulesJson);

  const planned = allRoutines
    .filter((r) => r.decision === "planned")
    .map((r) => ({
      name: r.name.toLowerCase(),
      baseName: normalizeRoutineName(r.name),
      purpose: normalizePurpose(r.purpose),
    }));

  const domainIds = new Set(ruleConfig.domains.map((d) => d.id));
  if (!domainIds.has(ruleConfig.fallbackDomain)) {
    throw new Error(
      `fallbackDomain=\"${ruleConfig.fallbackDomain}\" is not present in domains list`,
    );
  }

  const overrides = ruleConfig.overrides ?? {};
  for (const [k, v] of Object.entries(overrides)) {
    if (!domainIds.has(v)) {
      throw new Error(`Override for ${k} references unknown domain: ${v}`);
    }
  }

  const compiledRules = compileRules(ruleConfig);

  /** @type {Map<string, {name: string; baseName: string; purpose: string}[]>} */
  const grouped = new Map();
  for (const d of ruleConfig.domains) grouped.set(d.id, []);

  let fallbackCount = 0;

  for (const r of planned) {
    const override = overrides[r.baseName];
    let domain = override;

    if (!domain) {
      for (const rule of compiledRules) {
        if (rule.test(r)) {
          domain = rule.domain;
          break;
        }
      }
    }

    if (!domain) {
      domain = ruleConfig.fallbackDomain;
      fallbackCount++;
    }

    if (!domainIds.has(domain)) {
      throw new Error(`Routine ${r.name} assigned unknown domain: ${domain}`);
    }

    grouped.get(domain).push(r);
  }

  const md = renderMarkdown({
    plannedRoutines: planned,
    domains: ruleConfig.domains,
    grouped,
    fallbackDomain: ruleConfig.fallbackDomain,
    unmatchedCount: fallbackCount,
  });

  await mkdir(path.dirname(OUTPUT_PATH), { recursive: true });

  if (check) {
    const existing = await readFile(OUTPUT_PATH, "utf8").catch(() => null);
    if (existing !== md) {
      process.stderr.write(
        `docs/cspice-planned-functions-by-domain.md is out of date. Re-run:\n\n  node scripts/generate-cspice-planned-functions-by-domain.mjs\n`,
      );
      process.exit(1);
    }
    return;
  }

  await writeFile(OUTPUT_PATH, md, "utf8");
  process.stdout.write(`Wrote ${path.relative(REPO_ROOT, OUTPUT_PATH)}\n`);
  process.stdout.write(`Fallback (\\\"${ruleConfig.fallbackDomain}\\\") classified: ${fallbackCount}\n`);
}

main().catch((err) => {
  process.stderr.write(String(err?.stack ?? err) + "\n");
  process.exit(1);
});
