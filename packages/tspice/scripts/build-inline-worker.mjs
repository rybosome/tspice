import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import * as esbuild from "esbuild";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, "..", "..", "..");
const tspiceRoot = path.join(repoRoot, "packages", "tspice");
const backendWasmRoot = path.join(repoRoot, "packages", "backend-wasm");

const tspiceDist = path.join(tspiceRoot, "dist");

const workerEntryPath = path.join(
  tspiceDist,
  "worker",
  "browser",
  "spiceWorkerEntry.js",
);

const inlineWorkerSourcePath = path.join(
  tspiceDist,
  "worker",
  "browser",
  "spiceWorkerInlineSource.js",
);

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function stageWasmBinaryForInlineWorker() {
  // The inline worker is created from a `blob:` URL, so the worker must be
  // configured with an explicit wasmUrl. We compute that URL in
  // `createSpiceWorker()` relative to the *published package* layout:
  //
  //   dist/worker/browser/createSpiceWorker.js
  //   backend-wasm/dist/tspice_backend_wasm.wasm
  //
  // In the monorepo workspace layout, that `backend-wasm/...` folder does not
  // exist under `packages/tspice/`, so we stage a copy for local builds/dev.
  const srcWasmPath = path.join(
    backendWasmRoot,
    "dist",
    "tspice_backend_wasm.wasm",
  );

  const fallbackWasmPath = path.join(
    backendWasmRoot,
    "emscripten",
    "tspice_backend_wasm.wasm",
  );

  const resolvedSrc = fs.existsSync(srcWasmPath) ? srcWasmPath : fallbackWasmPath;

  if (!fs.existsSync(resolvedSrc)) {
    throw new Error(
      [
        "Missing backend-wasm wasm binary.",
        `Expected either:\n- ${srcWasmPath}\n- ${fallbackWasmPath}`,
        "Did you run the backend-wasm build first? (pnpm -C packages/backend-wasm build)",
      ].join("\n"),
    );
  }

  const destWasmPath = path.join(
    tspiceRoot,
    "backend-wasm",
    "dist",
    "tspice_backend_wasm.wasm",
  );

  ensureDir(path.dirname(destWasmPath));
  fs.copyFileSync(resolvedSrc, destWasmPath);
}

async function buildInlineWorkerSource() {
  if (!fs.existsSync(workerEntryPath)) {
    throw new Error(
      `Missing worker entry at ${workerEntryPath}. Did you run pnpm -w build?`,
    );
  }

  const result = await esbuild.build({
    entryPoints: [workerEntryPath],
    bundle: true,
    write: false,
    format: "esm",
    platform: "browser",
    target: "es2022",
    legalComments: "none",
    sourcemap: false,
    minify: true,
    logLevel: "silent",
  });

  const output = result.outputFiles?.[0];
  if (!output) throw new Error("esbuild did not produce an output bundle");
  const workerBundle = output.text;
  const out = [
    "// AUTO-GENERATED FILE. DO NOT EDIT.",
    "// Generated by packages/tspice/scripts/build-inline-worker.mjs",
    "",
    `export const SPICE_WORKER_INLINE_SOURCE = ${JSON.stringify(workerBundle)};`,
    "",
  ].join("\n");

  ensureDir(path.dirname(inlineWorkerSourcePath));
  fs.writeFileSync(inlineWorkerSourcePath, out, "utf8");

  // `spiceWorkerInlineSource.ts` is a TS stub so we can emit `.d.ts` types.
  // TypeScript will also emit a `.js.map` for the stub, but this build step
  // overwrites the `.js` contents, so the source map becomes incorrect.
  try {
    fs.rmSync(`${inlineWorkerSourcePath}.map`);
  } catch {
    // ignore
  }
}

async function main() {
  stageWasmBinaryForInlineWorker();
  await buildInlineWorkerSource();
}

await main();
