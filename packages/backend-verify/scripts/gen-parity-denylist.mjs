#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { computeContractKeys, stableCompare } from "./parity-contract-keys.mjs";

function printUsage() {
  console.log(`Usage: node ./packages/backend-verify/scripts/gen-parity-denylist.mjs [--missing] [--ts]\n\nOptions:\n  --missing  Output only missing parity scenario coverage keys (contractKeys - scenarioCalls).\n  --ts       Output a TypeScript module for packages/backend-verify/src/parity/parityScenarioDenylist.ts.\n`);
}

const args = new Set(process.argv.slice(2));
const argv = {
  help: args.has("--help") || args.has("-h"),
  missing: args.has("--missing"),
  ts: args.has("--ts"),
};

if (argv.help) {
  printUsage();
  process.exit(0);
}

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const contractIndexPath = path.resolve(scriptDir, "../../backend-contract/src/index.ts");
const contractDomainsDir = path.resolve(scriptDir, "../../backend-contract/src/domains");

const contractKeys = computeContractKeys({
  indexPath: contractIndexPath,
  domainsDir: contractDomainsDir,
}).toSorted(stableCompare);

function listScenarioPaths() {
  const scenariosDir = path.resolve(scriptDir, "../scenarios");
  if (!fs.existsSync(scenariosDir)) {
    throw new Error(`Scenarios dir not found: ${scenariosDir}`);
  }

  return fs
    .readdirSync(scenariosDir)
    .filter((p) => p.endsWith(".yml") || p.endsWith(".yaml"))
    .map((p) => path.join(scenariosDir, p))
    .sort(stableCompare);
}

function extractCallValuesFromYamlText(yamlText) {
  const calls = new Set();
  for (const line of yamlText.split(/\r?\n/)) {
    const m = line.match(/^\s*call:\s*(.+?)\s*$/);
    if (!m) continue;

    let value = m[1].trim();

    // Strip inline comments (best-effort; safe for our current scenario style).
    const hashIdx = value.indexOf("#");
    if (hashIdx !== -1) {
      value = value.slice(0, hashIdx).trim();
    }

    // Strip surrounding quotes.
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    if (value) {
      calls.add(value);
    }
  }
  return calls;
}

function getScenarioCalls() {
  const calls = new Set();
  for (const scenarioPath of listScenarioPaths()) {
    const yamlText = fs.readFileSync(scenarioPath, "utf8");
    for (const call of extractCallValuesFromYamlText(yamlText)) {
      calls.add(call);
    }
  }
  return calls;
}

const scenarioCalls = argv.missing ? getScenarioCalls() : null;
const denylist = (argv.missing
  ? contractKeys.filter((k) => !scenarioCalls.has(k))
  : contractKeys
).toSorted(stableCompare);

if (argv.ts) {
  const invocation = [
    "node",
    "./packages/backend-verify/scripts/gen-parity-denylist.mjs",
    ...process.argv.slice(2),
  ].join(" ");

  console.log(`// Generated by: ${invocation}`);
  console.log(`// Source: SpiceBackend contract in packages/backend-contract/src/index.ts`);
  console.log(`// Extracted from: packages/backend-contract/src/domains/*`);
  if (argv.missing) {
    console.log(`// Mode: missing coverage keys (contractKeys - scenarioCalls)`);
    console.log(`// Scenarios: packages/backend-verify/scenarios/*.yml`);
  }
  console.log("");

  console.log("export const PARITY_SCENARIO_DENYLIST = [");
  for (const entry of denylist) {
    console.log(`  ${JSON.stringify(entry)},`);
  }
  console.log("] as const;\n");
} else {
  console.log(JSON.stringify(denylist));
}
