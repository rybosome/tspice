import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

import * as ts from "typescript";

function stableCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

function readSourceFile(filePath) {
  const text = fs.readFileSync(filePath, "utf8");
  return ts.createSourceFile(filePath, text, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
}

function getExportedInterface(sourceFile, interfaceName) {
  for (const stmt of sourceFile.statements) {
    if (!ts.isInterfaceDeclaration(stmt)) continue;
    if (stmt.name.text !== interfaceName) continue;

    const isExported = (ts.getCombinedModifierFlags(stmt) & ts.ModifierFlags.Export) !== 0;
    if (!isExported) continue;

    return stmt;
  }

  return null;
}

function extractSpiceBackendApis(indexSourceFile) {
  for (const stmt of indexSourceFile.statements) {
    if (!ts.isInterfaceDeclaration(stmt)) continue;
    if (stmt.name.text !== "SpiceBackend") continue;

    const extendsClause = stmt.heritageClauses?.find((c) => c.token === ts.SyntaxKind.ExtendsKeyword);
    if (!extendsClause) {
      throw new Error("SpiceBackend has no extends clause (unexpected)");
    }

    const apiNames = extendsClause.types
      .map((t) => t.expression)
      .map((expr) => (ts.isIdentifier(expr) ? expr.text : expr.getText(indexSourceFile)))
      .filter((n) => n.endsWith("Api"));

    return apiNames;
  }

  throw new Error("Could not find interface SpiceBackend in backend-contract/src/index.ts");
}

function computeContractKeys({ indexPath, domainsDir }) {
  const indexSf = readSourceFile(indexPath);
  const apiNames = extractSpiceBackendApis(indexSf);

  const domainFiles = fs
    .readdirSync(domainsDir)
    .filter((f) => f.endsWith(".ts"))
    .sort(stableCompare);

  const keys = [];

  for (const apiName of apiNames) {
    let apiFilePath = null;

    for (const file of domainFiles) {
      const p = path.join(domainsDir, file);
      const sf = readSourceFile(p);
      const iface = getExportedInterface(sf, apiName);
      if (iface) {
        apiFilePath = p;
        break;
      }
    }

    if (!apiFilePath) {
      throw new Error(`Could not locate exported interface ${apiName} in backend-contract/src/domains/*.ts`);
    }

    const domain = path.basename(apiFilePath, ".ts");
    const sf = readSourceFile(apiFilePath);
    const iface = getExportedInterface(sf, apiName);
    if (!iface) {
      throw new Error(`Found file for ${apiName} but could not re-locate exported interface (unexpected): ${apiFilePath}`);
    }

    const methodNames = new Set();
    for (const member of iface.members) {
      if (!ts.isMethodSignature(member)) continue;

      const name = member.name;
      if (ts.isIdentifier(name) || ts.isStringLiteral(name) || ts.isNumericLiteral(name)) {
        methodNames.add(name.text);
      } else {
        throw new Error(
          `Unsupported method name kind while parsing ${apiName} in ${apiFilePath}: ${ts.SyntaxKind[name.kind]}`,
        );
      }
    }

    for (const methodName of Array.from(methodNames).sort(stableCompare)) {
      keys.push(`${domain}.${methodName}`);
    }
  }

  return Array.from(new Set(keys)).sort(stableCompare);
}

const scriptDir = path.dirname(fileURLToPath(import.meta.url));

const contractIndexPath = path.resolve(scriptDir, "../../backend-contract/src/index.ts");
const contractDomainsDir = path.resolve(scriptDir, "../../backend-contract/src/domains");

const contractKeys = computeContractKeys({ indexPath: contractIndexPath, domainsDir: contractDomainsDir });

const format = process.argv.includes("--ts") ? "ts" : process.argv.includes("--lines") ? "lines" : "json";

if (format === "lines") {
  for (const k of contractKeys) console.log(k);
} else if (format === "ts") {
  console.log(
    [
      "// Generated by: node ./packages/backend-verify/scripts/gen-parity-denylist.mjs --ts",
      "// Source: SpiceBackend contract in packages/backend-contract/src/index.ts",
      "",
      `export const PARITY_SCENARIO_DENYLIST = ${JSON.stringify(contractKeys, null, 2)} as const;`,
      "",
    ].join("\n"),
  );
} else {
  console.log(JSON.stringify(contractKeys, null, 2));
}
