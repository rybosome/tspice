#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { parse as parseYaml } from "yaml";

import { computeContractKeys, stableCompare } from "./parity-contract-keys.mjs";

function printUsage() {
  console.log(`Usage: node ./packages/backend-verify/scripts/gen-parity-denylist.mjs [--missing] [--ts]\n\nOptions:\n  --missing  Output only missing parity scenario coverage keys (contractKeys - scenarioCalls).\n  --ts       Output a TypeScript module for packages/backend-verify/src/parity/parityScenarioDenylist.ts.\n`);
}

const args = new Set(process.argv.slice(2));
const argv = {
  help: args.has("--help") || args.has("-h"),
  missing: args.has("--missing"),
  ts: args.has("--ts"),
};

if (argv.help) {
  printUsage();
  process.exit(0);
}

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const contractIndexPath = path.resolve(scriptDir, "../../backend-contract/src/index.ts");
const contractDomainsDir = path.resolve(scriptDir, "../../backend-contract/src/domains");

const contractKeys = computeContractKeys({
  indexPath: contractIndexPath,
  domainsDir: contractDomainsDir,
}).slice().sort(stableCompare);

function listScenarioPaths() {
  const scenariosDir = path.resolve(scriptDir, "../scenarios");
  if (!fs.existsSync(scenariosDir)) {
    throw new Error(`Scenarios dir not found: ${scenariosDir}`);
  }

  return fs
    .readdirSync(scenariosDir)
    .filter((p) => p.endsWith(".yml") || p.endsWith(".yaml"))
    .map((p) => path.join(scenariosDir, p))
    .sort(stableCompare);
}

function extractCallValuesFromYamlText(yamlText, sourcePath) {
  const calls = new Set();

  let data;
  try {
    data = parseYaml(yamlText);
  } catch (err) {
    const suffix = sourcePath ? ` (sourcePath=${sourcePath})` : "";
    throw new Error(`Failed to parse scenario YAML${suffix}: ${String(err)}`);
  }

  function visit(value) {
    if (Array.isArray(value)) {
      for (const v of value) visit(v);
      return;
    }
    if (!value || typeof value !== "object") {
      return;
    }

    for (const [k, v] of Object.entries(value)) {
      if (k === "call" && typeof v === "string" && v) {
        calls.add(v);
      }
      visit(v);
    }
  }

  visit(data);
  return calls;
}

function getScenarioCalls() {
  const calls = new Set();
  for (const scenarioPath of listScenarioPaths()) {
    const yamlText = fs.readFileSync(scenarioPath, "utf8");
    for (const call of extractCallValuesFromYamlText(yamlText, scenarioPath)) {
      calls.add(call);
    }
  }
  return calls;
}

const scenarioCalls = argv.missing ? getScenarioCalls() : null;
const denylist = (argv.missing
  ? contractKeys.filter((k) => !scenarioCalls.has(k))
  : contractKeys
).slice().sort(stableCompare);

if (argv.ts) {
  const invocation = [
    "node",
    "./packages/backend-verify/scripts/gen-parity-denylist.mjs",
    ...process.argv.slice(2),
  ].join(" ");

  console.log(`// Generated by: ${invocation}`);
  console.log(`// Source: SpiceBackend contract in packages/backend-contract/src/index.ts`);
  console.log(`// Extracted from: packages/backend-contract/src/domains/*`);
  if (argv.missing) {
    console.log(`// Mode: missing coverage keys (contractKeys - scenarioCalls)`);
    console.log(`// Scenarios: packages/backend-verify/scenarios/*.yml`);
  }
  console.log("");

  console.log("export const PARITY_SCENARIO_DENYLIST = [");
  for (const entry of denylist) {
    console.log(`  ${JSON.stringify(entry)},`);
  }
  console.log("] as const;\n");
} else {
  console.log(JSON.stringify(denylist));
}
