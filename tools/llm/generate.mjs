import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function readTextFile(absPath) {
  return fs.readFileSync(absPath, "utf8");
}

function ensureTrailingNewline(text) {
  return text.endsWith("\n") ? text : text + "\n";
}

function writeTextFile(absPath, content) {
  fs.mkdirSync(path.dirname(absPath), { recursive: true });
  fs.writeFileSync(absPath, ensureTrailingNewline(content), "utf8");
}

function writeJsonFile(absPath, value) {
  const json = JSON.stringify(value, null, 2);
  writeTextFile(absPath, json);
}

function sortUnique(values) {
  return [...new Set(values)].sort((a, b) => a.localeCompare(b));
}

function extractNamedExports(indexTsSource) {
  /** @type {string[]} */
  const typeExports = [];
  /** @type {string[]} */
  const valueExports = [];

  // Matches `export { a, b as c } from "...";` and `export type { ... } from "...";`
  const re = /export\s+(type\s+)?\{([\s\S]*?)\}\s*from\s*["'][^"']+["']\s*;?/g;
  for (const match of indexTsSource.matchAll(re)) {
    const isTypeOnly = Boolean(match[1]);
    const raw = match[2] ?? "";

    const names = raw
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean)
      .map((s) => {
        // Drop inline comments.
        const noComment = s.replace(/\/\/.*$/, "").trim();
        // `Foo as Bar` -> `Bar`
        const asMatch = noComment.match(/^(.*?)\s+as\s+(.*?)$/);
        return (asMatch ? asMatch[2] : noComment).trim();
      })
      .filter(Boolean);

    if (isTypeOnly) {
      typeExports.push(...names);
    } else {
      valueExports.push(...names);
    }
  }

  // Matches `export type Foo = ...` / `export interface Foo ...` / `export class Foo ...` etc.
  // Not currently used by packages/tspice/src/index.ts, but included for completeness.
  const directRe = /^export\s+(type|interface|class|const|function|enum)\s+([A-Za-z0-9_$]+)/gm;
  for (const match of indexTsSource.matchAll(directRe)) {
    // Ignore `export type { ... }` (handled above)
    if (match[0].includes("{")) continue;
    const kind = match[1];
    const name = match[2];
    if (!name) continue;
    if (kind === "type" || kind === "interface") {
      typeExports.push(name);
    } else {
      valueExports.push(name);
    }
  }

  return {
    typeExports: sortUnique(typeExports),
    valueExports: sortUnique(valueExports),
  };
}

function extractKernelSourceTypeDefinition(sharedTypesTsSource) {
  const lines = sharedTypesTsSource.split(/\r?\n/);
  const startIdx = lines.findIndex((l) => l.startsWith("export type KernelSource"));
  invariant(startIdx !== -1, "Could not find `export type KernelSource` in shared types file");

  const out = [];
  for (let i = startIdx; i < lines.length; i++) {
    out.push(lines[i]);
    if (lines[i].trim() === "};") {
      break;
    }
  }

  // Basic sanity check: ensure we stopped at the end of the union.
  invariant(out.at(-1)?.trim() === "};", "Failed to extract full KernelSource type (missing closing `};`)");

  return out.join("\n");
}

function readExamples(exampleDirAbs, repoRootAbs) {
  invariant(fs.existsSync(exampleDirAbs), `Missing examples directory: ${path.relative(repoRootAbs, exampleDirAbs)}`);

  const entries = fs.readdirSync(exampleDirAbs, { withFileTypes: true });
  const files = entries
    .filter((e) => e.isFile() && e.name.endsWith(".ts"))
    .map((e) => e.name)
    .sort((a, b) => a.localeCompare(b));

  invariant(files.length > 0, `No .ts examples found in: ${path.relative(repoRootAbs, exampleDirAbs)}`);

  return files.map((name) => {
    const absPath = path.join(exampleDirAbs, name);
    const relPath = path.relative(repoRootAbs, absPath).replaceAll(path.sep, "/");
    const content = readTextFile(absPath).trimEnd();
    return { relPath, content };
  });
}

function buildLlmsTxt() {
  return `# tspice\n\nTypeScript-first wrapper around NAIF SPICE (CSPICE), with multiple backends (WASM + Node/native).\n\nThis file (and its sibling artifacts) are generated by \`pnpm generate:llm\`.\n\n## Artifacts\n\n- Full LLM-focused documentation + typechecked golden examples: \`./llms-full.txt\`\n- JSON schema for tool/integration builders (common kit operations): \`./tspice.schema.json\`\n\nHosted (GitHub Pages):\n\n- https://rybosome.github.io/tspice/llms.txt\n- https://rybosome.github.io/tspice/llms-full.txt\n- https://rybosome.github.io/tspice/tspice.schema.json\n\n## Policies / disclosures (repo files)\n\n- \`docs/cspice-policy.md\`\n- \`docs/cspice-naif-disclosure.md\`\n- \`THIRD_PARTY_NOTICES.md\`\n\n## Non-goals / do not assume\n\n- This repo does **not** ship SPICE kernels; callers must provide kernels (LSK/SPK/FK/etc) appropriate to their use case.\n- Do not assume \`backend: \"node\"\` is available everywhere; it depends on a native addon. Prefer \`backend: \"wasm\"\` for portability.\n- Do not assume network access; kernel bytes may come from local files, fetch, or other sources.\n`;
}

function buildLlmsFullTxt({ exports, kernelSourceType, examples }) {
  const exportSection = `## Public API surface (generated)\n\nSource: \`packages/tspice/src/index.ts\`\n\n### Value exports\n\n${exports.valueExports.map((n) => `- \`${n}\``).join("\n")}\n\n### Type exports\n\n${exports.typeExports.map((n) => `- \`${n}\``).join("\n")}\n`;

  const kernelSourceSection = `## KernelSource (generated)\n\nSource: \`packages/backend-contract/src/shared/types.ts\`\n\n\`\`\`ts\n${kernelSourceType}\n\`\`\`\n\nNotes:\n\n- \`KernelSource\` is accepted by \`spice.kit.loadKernel()\` and lower-level backend APIs like \`raw.furnsh()\`.\n- Passing an object form (\`{ path, bytes }\`) is the most portable approach across WASM + Node backends.\n`;

  const examplesSection = `## Golden examples (typechecked in CI)\n\nThese example files are committed and typechecked as part of the monorepo TypeScript build.\n\n${examples
    .map(
      (ex) =>
        `### \`${ex.relPath}\`\n\n\`\`\`ts\n${ex.content}\n\`\`\``,
    )
    .join("\n\n")}\n`;

  const policiesSection = `## Policies / disclosures\n\nThese are the canonical repo files:\n\n- \`docs/cspice-policy.md\`\n- \`docs/cspice-naif-disclosure.md\`\n- \`THIRD_PARTY_NOTICES.md\`\n`;

  const nonGoalsSection = `## Non-goals / do not assume\n\n- **No kernels included.** tspice does not bundle NAIF kernels; you must provide and load kernels explicitly.\n- **No implicit backend selection.** Choose \`backend: \"wasm\"\` or \`backend: \"node\"\`.\n- **No guarantee of native availability.** The Node backend requires a platform-specific native addon; WASM is the most portable default.\n- **No internet assumptions.** Some environments disallow network access; design your kernel-loading strategy accordingly.\n- **Not an orbital mechanics library.** tspice is a SPICE wrapper; higher-level mission logic is out of scope.\n`;

  const generatorSection = `## Regenerating these artifacts\n\nFrom the repo root:\n\n\`\`\`sh\npnpm generate:llm\n\`\`\`\n\nGenerated outputs:\n\n- \`llms.txt\`\n- \`apps/docs/public/llms.txt\`\n- \`apps/docs/public/llms-full.txt\`\n- \`apps/docs/public/tspice.schema.json\`\n`;

  return `# tspice â€” LLM/tool artifacts (full)\n\nThis document is intended for LLMs and tool builders. It describes the public surface area of \`@rybosome/tspice\`, key types, and includes typechecked examples.\n\n${exportSection}\n\n${kernelSourceSection}\n\n${examplesSection}\n\n${policiesSection}\n\n${nonGoalsSection}\n\n${generatorSection}`;
}

function buildSchema({ exports, kernelSourceType }) {
  return {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://rybosome.github.io/tspice/tspice.schema.json",
    title: "tspice (tool/integration schema)",
    description:
      "A small JSON schema intended for LLM/tool integrations. It models a portable request format for common @rybosome/tspice kit operations.",

    type: "object",
    additionalProperties: false,
    required: ["backend", "calls"],
    properties: {
      backend: {
        type: "string",
        enum: ["wasm", "node"],
        description: "Select the tspice backend implementation.",
      },
      calls: {
        type: "array",
        items: { $ref: "#/$defs/SpiceKitCall" },
      },
    },

    $defs: {
      // JSON-friendly encoding of the TS type:
      //
      // export type KernelSource =
      //   | string
      //   | { path: string; bytes: Uint8Array };
      KernelSource: {
        oneOf: [
          {
            type: "string",
            description:
              "Kernel path. On Node, this may be an OS filesystem path. On WASM, prefer the object form with bytes.",
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["path", "bytes"],
            properties: {
              path: {
                type: "string",
                description:
                  "Virtual kernel identifier. Keep it stable so you can unload later (kit.unloadKernel).",
              },
              bytes: {
                type: "string",
                contentEncoding: "base64",
                contentMediaType: "application/octet-stream",
                description: "Base64-encoded kernel bytes (convert to Uint8Array in JS).",
              },
            },
          },
        ],
      },

      AberrationCorrection: {
        type: "string",
        enum: ["NONE", "LT", "LT+S", "CN", "CN+S", "XLT", "XLT+S", "XCN", "XCN+S"],
      },

      BodyRef: {
        oneOf: [{ type: "string" }, { type: "integer" }],
      },

      SpiceKitCall: {
        oneOf: [
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "loadKernel" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["kernel"],
                properties: {
                  kernel: { $ref: "#/$defs/KernelSource" },
                },
              },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "unloadKernel" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["path"],
                properties: {
                  path: { type: "string" },
                },
              },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op"],
            properties: {
              op: { const: "kclear" },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "utcToEt" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["utc"],
                properties: {
                  utc: { type: "string" },
                },
              },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "etToUtc" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["et"],
                properties: {
                  et: { type: "number" },
                  format: { type: "string" },
                  prec: { type: "integer" },
                },
              },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "frameTransform" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["from", "to", "et"],
                properties: {
                  from: { type: "string" },
                  to: { type: "string" },
                  et: { type: "number" },
                },
              },
            },
          },
          {
            type: "object",
            additionalProperties: false,
            required: ["op", "args"],
            properties: {
              op: { const: "getState" },
              args: {
                type: "object",
                additionalProperties: false,
                required: ["target", "observer", "at"],
                properties: {
                  target: { $ref: "#/$defs/BodyRef" },
                  observer: { $ref: "#/$defs/BodyRef" },
                  at: { type: "number" },
                  frame: { type: "string" },
                  aberration: { $ref: "#/$defs/AberrationCorrection" },
                },
              },
            },
          },
        ],
      },
    },

    // Extra machine-readable metadata (non-standard keywords are OK in JSON Schema).
    xTspice: {
      sourceFiles: {
        publicIndex: "packages/tspice/src/index.ts",
        kernelSourceType: "packages/backend-contract/src/shared/types.ts",
      },
      exportedSymbols: exports,
      kernelSourceTypeScript: kernelSourceType,
      generatedBy: "tools/llm/generate.mjs",
    },
  };
}

function main() {
  const scriptPath = fileURLToPath(import.meta.url);
  const scriptDir = path.dirname(scriptPath);
  const repoRoot = path.resolve(scriptDir, "../..");

  const tspiceIndexAbs = path.join(repoRoot, "packages/tspice/src/index.ts");
  const backendContractTypesAbs = path.join(
    repoRoot,
    "packages/backend-contract/src/shared/types.ts",
  );

  const exports = extractNamedExports(readTextFile(tspiceIndexAbs));
  const kernelSourceType = extractKernelSourceTypeDefinition(readTextFile(backendContractTypesAbs));

  const examplesDirAbs = path.join(repoRoot, "packages/tspice/test/llm-examples");
  const examples = readExamples(examplesDirAbs, repoRoot);

  const llmsTxt = buildLlmsTxt();
  const llmsFull = buildLlmsFullTxt({ exports, kernelSourceType, examples });
  const schema = buildSchema({ exports, kernelSourceType });

  writeTextFile(path.join(repoRoot, "llms.txt"), llmsTxt);
  writeTextFile(path.join(repoRoot, "apps/docs/public/llms.txt"), llmsTxt);
  writeTextFile(path.join(repoRoot, "apps/docs/public/llms-full.txt"), llmsFull);
  writeJsonFile(path.join(repoRoot, "apps/docs/public/tspice.schema.json"), schema);

  console.log("[generate:llm] wrote llms.txt + apps/docs/public/{llms.txt,llms-full.txt,tspice.schema.json}");
}

main();
