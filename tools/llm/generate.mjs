import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function readTextFile(absPath) {
  return fs.readFileSync(absPath, "utf8");
}

function ensureTrailingNewline(text) {
  return text.endsWith("\n") ? text : text + "\n";
}

function writeTextFile(absPath, content) {
  fs.mkdirSync(path.dirname(absPath), { recursive: true });
  fs.writeFileSync(absPath, ensureTrailingNewline(content), "utf8");
}

function writeJsonFile(absPath, value) {
  const json = JSON.stringify(value, null, 2);
  writeTextFile(absPath, json);
}

function sortUnique(values) {
  return [...new Set(values)].sort((a, b) => a.localeCompare(b));
}

function extractNamedExports(indexTsSource) {
  /** @type {string[]} */
  const typeExports = [];
  /** @type {string[]} */
  const valueExports = [];

  // Matches `export { a, b as c } from "...";` and `export type { ... } from "...";`
  const re = /export\s+(type\s+)?\{([\s\S]*?)\}\s*from\s*["'][^"']+["']\s*;?/g;
  for (const match of indexTsSource.matchAll(re)) {
    const isTypeOnly = Boolean(match[1]);
    const raw = match[2] ?? "";

    const names = raw
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean)
      .map((s) => {
        // Drop inline comments.
        const noComment = s.replace(/\/\/.*$/, "").trim();
        // `Foo as Bar` -> `Bar`
        const asMatch = noComment.match(/^(.*?)\s+as\s+(.*?)$/);
        return (asMatch ? asMatch[2] : noComment).trim();
      })
      .filter(Boolean);

    if (isTypeOnly) {
      typeExports.push(...names);
    } else {
      valueExports.push(...names);
    }
  }

  // Matches `export type Foo = ...` / `export interface Foo ...` / `export class Foo ...` etc.
  // Not currently used by packages/tspice/src/index.ts, but included for completeness.
  const directRe = /^export\s+(type|interface|class|const|function|enum)\s+([A-Za-z0-9_$]+)/gm;
  for (const match of indexTsSource.matchAll(directRe)) {
    // Ignore `export type { ... }` (handled above)
    if (match[0].includes("{")) continue;
    const kind = match[1];
    const name = match[2];
    if (!name) continue;
    if (kind === "type" || kind === "interface") {
      typeExports.push(name);
    } else {
      valueExports.push(name);
    }
  }

  return {
    typeExports: sortUnique(typeExports),
    valueExports: sortUnique(valueExports),
  };
}

function extractKernelSourceTypeDefinition(sharedTypesTsSource) {
  const lines = sharedTypesTsSource.split(/\r?\n/);
  const startIdx = lines.findIndex((l) => l.startsWith("export type KernelSource"));
  invariant(startIdx !== -1, "Could not find `export type KernelSource` in shared types file");

  const out = [];
  for (let i = startIdx; i < lines.length; i++) {
    out.push(lines[i]);
    if (lines[i].trim() === "};") {
      break;
    }
  }

  // Basic sanity check: ensure we stopped at the end of the union.
  invariant(out.at(-1)?.trim() === "};", "Failed to extract full KernelSource type (missing closing `};`)");

  return out.join("\n");
}

function readExamples(exampleDirAbs, repoRootAbs) {
  invariant(fs.existsSync(exampleDirAbs), `Missing examples directory: ${path.relative(repoRootAbs, exampleDirAbs)}`);

  const entries = fs.readdirSync(exampleDirAbs, { withFileTypes: true });
  const files = entries
    .filter((e) => e.isFile() && e.name.endsWith(".ts"))
    .map((e) => e.name)
    .sort((a, b) => a.localeCompare(b));

  invariant(files.length > 0, `No .ts examples found in: ${path.relative(repoRootAbs, exampleDirAbs)}`);

  return files.map((name) => {
    const absPath = path.join(exampleDirAbs, name);
    const relPath = path.relative(repoRootAbs, absPath).replaceAll(path.sep, "/");
    const content = readTextFile(absPath).trimEnd();
    return { relPath, content };
  });
}

function buildLlmsTxt() {
  return `# tspice

TypeScript-first wrapper around NAIF SPICE (CSPICE).

Supported environments / backends:

- browser/WebWorker (WASM)
- Node.js (native addon)

This file (and its sibling artifacts) are generated by \`pnpm generate:llm\`.

## Artifacts

Hosted (GitHub Pages):

- https://rybosome.github.io/tspice/llms.txt
- https://rybosome.github.io/tspice/llms-full.txt
- https://rybosome.github.io/tspice/tspice.schema.json

Repo paths:

- \`apps/docs/public/llms-full.txt\` — full LLM-focused documentation + typechecked golden examples
- \`apps/docs/public/tspice.schema.json\` — structured JSON metadata summary for tools/LLMs

## Policies / disclosures (repo files)

- \`docs/cspice-policy.md\`
- \`docs/cspice-naif-disclosure.md\`
- \`THIRD_PARTY_NOTICES.md\`

## Non-goals / do not assume

- This repo does **not** ship SPICE kernels; callers must provide kernels (LSK/SPK/FK/etc) appropriate to their use case.
- Do not assume \`backend: "node"\` is available everywhere; it depends on a native addon (Node.js (native addon)). Prefer \`backend: "wasm"\` for browser/WebWorker (WASM) portability.
- Do not assume network access; kernel bytes may come from local files, fetch, or other sources.
`;
}
function buildLlmsFullTxt({ exports, kernelSourceType, examples }) {
  const exportSection = `## Public API surface (generated)\n\nSource: \`packages/tspice/src/index.ts\`\n\n### Value exports\n\n${exports.valueExports.map((n) => `- \`${n}\``).join("\n")}\n\n### Type exports\n\n${exports.typeExports.map((n) => `- \`${n}\``).join("\n")}\n`;

  const kernelSourceSection = `## KernelSource (generated)\n\nSource: \`packages/backend-contract/src/shared/types.ts\`\n\n\`\`\`ts\n${kernelSourceType}\n\`\`\`\n\nNotes:\n\n- \`KernelSource\` is accepted by \`spice.kit.loadKernel()\` and lower-level backend APIs like \`raw.furnsh()\`.\n- Passing an object form (\`{ path, bytes }\`) is the most portable approach across WASM + Node backends.\n`;

  const examplesSection = `## Golden examples (typechecked in CI)\n\nThese example files are committed and typechecked as part of the monorepo TypeScript build.\n\n${examples
    .map(
      (ex) =>
        `### \`${ex.relPath}\`\n\n\`\`\`ts\n${ex.content}\n\`\`\``,
    )
    .join("\n\n")}\n`;

  const policiesSection = `## Policies / disclosures\n\nThese are the canonical repo files:\n\n- \`docs/cspice-policy.md\`\n- \`docs/cspice-naif-disclosure.md\`\n- \`THIRD_PARTY_NOTICES.md\`\n`;

  const nonGoalsSection = `## Non-goals / do not assume\n\n- **No kernels included.** tspice does not bundle NAIF kernels; you must provide and load kernels explicitly.\n- **No implicit backend selection.** Choose \`backend: "wasm"\` or \`backend: "node"\`.\n- **No guarantee of native availability.** The Node backend requires a platform-specific native addon; WASM is the most portable default.\n- **No internet assumptions.** Some environments disallow network access; design your kernel-loading strategy accordingly.\n- **Not an orbital mechanics library.** tspice is a SPICE wrapper; higher-level mission logic is out of scope.\n`;

  const generatorSection = `## Regenerating these artifacts\n\nFrom the repo root:\n\n\`\`\`sh\npnpm generate:llm\n\`\`\`\n\nGenerated outputs:\n\n- \`llms.txt\`\n- \`apps/docs/public/llms.txt\`\n- \`apps/docs/public/llms-full.txt\`\n- \`apps/docs/public/tspice.schema.json\`\n`;

  return `# tspice — LLM/tool artifacts (full)\n\nThis document is intended for LLMs and tool builders. It describes the public surface area of \`@rybosome/tspice\`, key types, and includes typechecked examples.\n\n${exportSection}\n\n${kernelSourceSection}\n\n${examplesSection}\n\n${policiesSection}\n\n${nonGoalsSection}\n\n${generatorSection}`;
}

function buildTspiceSchemaSummary({ exports, kernelSourceType, examples }) {
  const exportValueDescriptions = {
    Mat3: "3×3 matrix helper for frame transforms and vector math.",
    J2000: "Constant frame name for the canonical inertial reference frame (J2000).",
    SpiceError: "Error thrown when underlying SPICE/CSPICE operations fail.",

    createBackend:
      "Create a low-level SPICE backend implementation (wasm or node) conforming to the backend contract.",
    createSpice:
      "Create a sync-ish tspice client (raw backend + higher-level kit helpers).",
    createSpiceAsync:
      "Create an async tspice client mirroring the sync surface area (all methods return Promises).",

    spiceClients:
      "Higher-level client builder that can produce in-process, async, or WebWorker clients and a dispose() lifecycle.",

    createPublicKernels:
      "Create a builder for assembling a small set of commonly-used public NAIF kernels (URLs + load paths).",
    publicKernels: "Preconfigured PublicKernelsBuilder with default options.",

    assertMat3ArrayLike9:
      "Runtime assertion that a value is a length-9 array-like suitable for a 3×3 matrix.",
    isMat3ArrayLike9:
      "Type guard that checks whether a value is a length-9 array-like suitable for a 3×3 matrix.",
    brandMat3ColMajor:
      "Type-brand a length-9 number array as Mat3ColMajor (column-major) without copying.",
    brandMat3RowMajor:
      "Type-brand a length-9 number array as Mat3RowMajor (row-major) without copying.",
    isBrandedMat3ColMajor:
      "Runtime predicate that checks whether a value is branded as Mat3ColMajor.",
    isBrandedMat3RowMajor:
      "Runtime predicate that checks whether a value is branded as Mat3RowMajor.",
  };

  const exportTypeDescriptions = {
    KernelSource:
      "Kernel identifier accepted by kit.loadKernel(): either a string path or an object with { path, bytes }.",
    SpiceBackend:
      "Low-level backend interface implemented by the WASM and Node.js backends.",

    Mat3ColMajor: "Branded type for a 3×3 matrix encoded in column-major order.",
    Mat3RowMajor: "Branded type for a 3×3 matrix encoded in row-major order.",

    CreateBackendOptions:
      "Options accepted by createBackend() (explicit backend selection + optional wasmUrl override).",

    AberrationCorrection:
      "Allowed aberration correction strings for state/position queries (e.g. 'NONE', 'LT', ...).",
    BodyRef: "Body identifier accepted by kit APIs (NAIF name string or numeric id).",
    FrameName: "SPICE frame name string (e.g. 'J2000', 'IAU_EARTH').",
    GetStateArgs: "Argument object for kit.getState() (target, observer, time, frame, aberration).",
    SpiceTime: "Seconds past J2000 (ET).",
    StateVector:
      "Structured result returned by kit.getState() (position, velocity, light time, and query metadata).",
    Vec3: "Readonly 3-vector tuple type.",
    Vec6: "Readonly 6-vector tuple type.",

    Spice: "Sync-ish client type: { raw, kit }.",
    SpiceSync: "Alias of Spice (sync-ish client).",
    SpiceAsync: "Async client type mirroring Spice; all methods return Promises.",
    SpiceKit: "High-level convenience API built on top of the raw backend.",

    CreateSpiceOptions:
      "Options accepted by createSpice(): backend selection + optional backendInstance override.",
    CreateSpiceAsyncOptions: "Alias of CreateSpiceOptions.",

    SpiceClientBuildResult:
      "Return type of spiceClients builders: { spice, dispose }. Dispose is idempotent + safe.",
    SpiceClientsBuilder:
      "Fluent builder for constructing spice clients (in-process sync/async or WebWorker), optionally with caching + kernels.",
    SpiceClientsWebWorkerOptions:
      "Options for spiceClients.toWebWorker() (custom Worker, wasmUrl override, timeouts, termination behavior).",

    CreatePublicKernelsOptions:
      "Options accepted by createPublicKernels() (urlBase + pathBase).",
    PublicKernelId:
      "Union of built-in public kernel ids (e.g. naif0012_tls, pck00011_tpc, de432s_bsp).",
    PublicKernelsBuilder:
      "Builder for selecting public kernels and producing a KernelPack.",

    KernelPack:
      "A small ordered set of kernels (URLs + load paths) intended to be fetched and loaded as a group.",
    KernelPackKernel:
      "A single kernel entry in a KernelPack: { url, path }.",
    LoadKernelPackOptions:
      "Options for kernelPack.loadKernelPack() (baseUrl behavior, fetch override, and fetch strategy).",
  };

  const exampleDescriptionsByPath = {
    "packages/tspice/test/llm-examples/backend-env-selection.example.ts":
      "Backend selection (Node vs WASM) + spiceClients lifecycle/dispose.",
    "packages/tspice/test/llm-examples/kernel-loading.example.ts":
      "Kernel loading patterns via KernelSource (filesystem path vs bytes).",
    "packages/tspice/test/llm-examples/state-and-frame-transform.example.ts":
      "Ephemeris state query (getState) + frame transform (frameTransform) + Mat3 usage.",
    "packages/tspice/test/llm-examples/time-conversion.example.ts": "UTC ↔ ET time conversions.",
  };

  const toExportEntries = (names, descriptions) =>
    names.map((name) => ({
      name,
      description: descriptions[name] ?? "Public export from @rybosome/tspice.",
    }));

  const goldenExamples = examples.map((ex) => ({
    repoPath: ex.relPath,
    description:
      exampleDescriptionsByPath[ex.relPath] ?? "Golden TypeScript example (typechecked in CI).",
  }));

  return {
    format: "tspice.schema.json",
    intent: "Structured JSON metadata summary for LLMs and tool/integration builders.",

    hostedUrls: {
      llmsTxt: "https://rybosome.github.io/tspice/llms.txt",
      llmsFullTxt: "https://rybosome.github.io/tspice/llms-full.txt",
      tspiceSchemaJson: "https://rybosome.github.io/tspice/tspice.schema.json",
    },

    environments: [
      {
        id: "wasm",
        name: "browser/WebWorker (WASM)",
        constraints: [
          "Portable default; works in browsers and other WASM-capable runtimes.",
          "No direct OS filesystem access; prefer loading kernels via bytes (KernelSource { path, bytes }).",
          "Large kernels can be memory-heavy; consider fetchStrategy='sequential' when loading packs.",
        ],
      },
      {
        id: "node",
        name: "Node.js (native addon)",
        constraints: [
          "Requires an optional, platform-specific native addon package.",
          "Can load kernels by OS filesystem path (KernelSource string) or via bytes.",
        ],
      },
    ],

    kernelSource: {
      sourceFile: "packages/backend-contract/src/shared/types.ts",
      typeScriptDefinition: kernelSourceType,
      notesByEnvironment: {
        wasm: [
          "Prefer the object form: { path, bytes }.",
          "String paths are backend-defined and generally refer to the WASM virtual filesystem, not the OS filesystem.",
        ],
        node: [
          "String form is typically treated as an OS filesystem path passed to the native backend's furnsh().",
          "The object form { path, bytes } is supported and is the most portable across environments.",
        ],
      },
    },

    exports: {
      sourceFile: "packages/tspice/src/index.ts",
      valueExports: toExportEntries(exports.valueExports, exportValueDescriptions),
      typeExports: toExportEntries(exports.typeExports, exportTypeDescriptions),
    },

    goldenExamples,

    policiesAndDisclosures: [
      {
        repoPath: "docs/cspice-policy.md",
        description: "Project policy for CSPICE usage and redistribution constraints.",
      },
      {
        repoPath: "docs/cspice-naif-disclosure.md",
        description: "NAIF/CSPICE disclosure guidance.",
      },
      {
        repoPath: "THIRD_PARTY_NOTICES.md",
        description: "Third-party notices and attributions.",
      },
    ],

    nonGoals: [
      "tspice does not bundle NAIF kernels; callers must provide and load kernels explicitly.",
      "Do not assume backend='node' works in all environments; it requires a Node.js native addon.",
      "Do not assume network access is available; design kernel loading accordingly.",
      "This file is metadata, not a complete spec for SPICE behavior; consult NAIF docs for SPICE semantics.",
    ],

    generatedBy: {
      script: "tools/llm/generate.mjs",
      command: "pnpm generate:llm",
      outputFile: "apps/docs/public/tspice.schema.json",
    },
  };
}
function main() {
  const scriptPath = fileURLToPath(import.meta.url);
  const scriptDir = path.dirname(scriptPath);
  const repoRoot = path.resolve(scriptDir, "../..");

  const tspiceIndexAbs = path.join(repoRoot, "packages/tspice/src/index.ts");
  const backendContractTypesAbs = path.join(
    repoRoot,
    "packages/backend-contract/src/shared/types.ts",
  );

  const exports = extractNamedExports(readTextFile(tspiceIndexAbs));
  const kernelSourceType = extractKernelSourceTypeDefinition(readTextFile(backendContractTypesAbs));

  const examplesDirAbs = path.join(repoRoot, "packages/tspice/test/llm-examples");
  const examples = readExamples(examplesDirAbs, repoRoot);

  const llmsTxt = buildLlmsTxt();
  const llmsFull = buildLlmsFullTxt({ exports, kernelSourceType, examples });
  const schema = buildTspiceSchemaSummary({ exports, kernelSourceType, examples });

  writeTextFile(path.join(repoRoot, "llms.txt"), llmsTxt);
  writeTextFile(path.join(repoRoot, "apps/docs/public/llms.txt"), llmsTxt);
  writeTextFile(path.join(repoRoot, "apps/docs/public/llms-full.txt"), llmsFull);
  writeJsonFile(path.join(repoRoot, "apps/docs/public/tspice.schema.json"), schema);

  console.log("[generate:llm] wrote llms.txt + apps/docs/public/{llms.txt,llms-full.txt,tspice.schema.json}");
}

main();
